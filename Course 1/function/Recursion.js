                           //!Ռեկուրսիա (Recursion)

// Ռեկուրսիան (Recursion) ֆունկցիոնալ ծրագրավորման և ընդհանուր ծրագրավորման կարևոր 
// տեխնիկա է, որի դեպքում ֆունկցիան ինքն իրեն կանչում է մեկ կամ ավելի անգամներ՝ 
// խնդիրների լուծումը ստորաբաժանելով ավելի փոքր, նույնատիպ խնդիրների: 

// Ռեկուրսիվ ֆունկցիան ունի երկու հիմնական մաս.

//1. Հիմնական դեպք: Որոշում է, թե երբ կանգնել ռեկուրսիան:
//2. Ռեկուրսիվ կանչ: Ֆունկցիան ինքն իրեն կանչում է խնդիրի փոքրացրած տարբերակով:


//!Օրինակ 1՝ Ֆակտորիալ Ֆունկցիա

// function factorial(n) {
//     // Հիմնական դեպք
//     if (n === 0) {
//         return 1;
//     }
//     // Ռեկուրսիվ կանչ
//     return n * factorial(n - 1);
// }

// console.log(factorial(5)); // Outputs: 120


//!Օրինակ 2՝ Ֆիբոնաչի Ֆունկցիա

// function fibonacci(n) {
//     // Հիմնական դեպքեր
//     if (n <= 1) {
//         return n;
//     }
//     // Ռեկուրսիվ կանչեր
//     return fibonacci(n - 1) + fibonacci(n - 2);
// }

// console.log(fibonacci(6)); // Outputs: 8



//! Օգտակարություն
// Ռեկուրսիան ունի մի քանի կարևոր առավելություններ.

//1. Պարզություն: Ռեկուրսիան թույլ է տալիս շատ բարդ խնդիրներ լուծել կոդի պարզ և ընթեռնելի ձևով:
//2. Բաժանում և նվաճում: Ռեկուրսիան բնական ձևով բաժանում է խնդիրները փոքր մասերի, ինչը հնարավորություն է տալիս դրանց հեշտ լուծումը:
//3. Բնորոշություն տվյալների կառուցվածքներին: Ռեկուրսիան լավ է համընկնում ծառերի, գրաֆների և նման տվյալների կառուցվածքների հետ:

//! Ռեկուրսիայի Դժվարություններ
// Չնայած ռեկուրսիայի օգտակարությանը, այն ունի նաև որոշ դժվարություններ.

//1. Զանգվածային բեռը: Ռեկուրսիան կարող է առաջացնել մեծ բեռ՝ ֆունկցիայի բազմաթիվ կանչերի պատճառով:
//2. Ստեկի ավելացում: Խորը ռեկուրսիան կարող է հանգեցնել ստեկի լցմանը (stack overflow):
//3. Օգտագործման բարդություն: Որոշ դեպքերում ռեկուրսիայի ճիշտ 
// օգտագործումը կարող է դժվար լինել:





                                   //! Ռեկուրսիայի Օպտիմիզացիա

//  Մեմոիզացիա: Պահպանել ֆունկցիայի հաշվարկված արժեքները, 
//  որպեսզի խուսափենք կրկնակի հաշվարկներից:

// Օրինակ՝ Մեմոիզացված Ֆիբոնաչի

// function fibonacciMemo() {
//     const memo = {};

//     function fibonacci(n) {
//         if (n <= 1) {
//             return n;
//         }
//         if (memo[n]) {
//             return memo[n];
//         }
//         memo[n] = fibonacci(n - 1) + fibonacci(n - 2);
//         return memo[n];
//     }

//     return fibonacci;
// }

// const fibonacci = fibonacciMemo();

// console.log(fibonacci(6)); // Outputs: 8
